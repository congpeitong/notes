#+TITLE: EMACS-LISP基础编程
#+AUTHOR: CONGPEITONG
* 第一章 列表处理
** Lisp列表
在lisp中，一个列表看起来像这个样子：'(rose violet daisy buttercupl)。这个列表以单引号开始。也可以写成如下形式
#+begin_src lisp
  '(rose
    violet
    daisy
    buttercupl)

#+end_src
在这个列表中，元素是四种不同花的名称，他们之间用空格分隔开，并用括号括起来，就像花在一个石头墙围起来的花园一样。

列表中也可以有数字，例如列表(+ 2 2)一样。这个列表有一个+号，后接两个2他们之间用空格分开。

在Lisp中数据和程序都以同样的方式表示；也就是说，他们都是由空格分隔开的、由括号括起来的单词、数字或者其它列表的列表。
（因为如果一个程序看起来像数据，那他就很容易作为其它程序的数据；这是Lisp中一个很有用的特性。）（附带提一下，对前面这对括号而言，
他们不是Lisp列表因为其中使用了标点符号;和。来分隔不同的元素。）

下面是另一个列表，这个列表中有另一个列表：
#+begin_src lisp
'(this list has (a list inside of it))
#+end_src
这个列表的元件是单词 this list has 和内部列表 (a list inside of it)。内部列表由 a list inside of it 这几个词组成
*** Lisp原子
在Lisp中我们刚才说到的词被称作原子(atom)。这个术语来自原子一词的历史含义，即原子意味着"不可分",只要提到Lisp,我们在列表中使用的
词就不可以再被分成更小的部分，这再程序中也一样。数字、单个字符（如：+）都是如此。另一方面不像原子，一个列表可以拆分成不同的部分，

在一个列表中，原子是由空格一一分隔的。原子可以紧接着括号。

从技术上说，Lisp中的列表有三种可能的组成方式：括号和括号中由空格分隔的原子；括号和括号中的其它列表；括号和括号中的其它列表及原子。
一个列表可以仅有一个原子，或者完全没有原子。一个没有任何原子的列表同时看作，既是一个原子，也是一个列表。

原子和列表的书面表示都被称作符号表达式(symbolic expression),或者更简洁地被称作 s-表达式 （s-expression）。表达式这个词，既可以
指书面的表示，也可以指一个原子或者一个列表在计算机中的内部表示。人们常常无区别的使用表达式这个词。（同样的，在许多书中，表格(form)
这个词被看作是表达式的同义词）。

顺便说一下，构成我们的宇宙的原子是在他们被认为是不可分割时候命名的。但是，人们已经发现，物理上的原子不再是不可分的。原子的一部分
可以被分出来，或者可以裂变成大致相等的两个部分。物理上的原子在他们的更真实的本质被发现之前就已被过早的命名。在Lisp中，某种类型的原子
，例如一个数组，可以被分成更小的部分，但是分割数组的机制与分割列表的机制是不同的。只要是涉及列表操作，列表中的原子就是不可分的。

与英语中一样，Lisp原子的组成字母的意义与由这些字母构成的单词的含义是不同的。例如，代表"South American sloth"的单词"ai"与a 和 i这两个字母
是完全不同的。

自然界中有许多种原子，但是在Lisp中只有几种原子；例如，数字 37 511 1729 和符号  + foo forward-line。以上列出的这些单词都是符号。
在Lisp的日常使用习惯中，"原子"一词不太常用，因为程序员经常试图更明确的表示他们的原子类型，Lisp编程几乎都是关于列表中的符号，且有时
是关于数字的。附带说一下，上述三个单词是Lisp中一个正确的列表，因为他包含的是原子。在这种情况下,原子是一些由空格分隔，用括号括起来的
符号，其中没有任何对Lisp而言是非法的标点符号。

另外，双引号中的文本-----不论是句子或者是段落，都是一个原子。下面是这样的一个例子：
#+begin_src lisp
'(this list include "text between quotation marks")
#+end_src
在Lisp中，所有用双引号括起来的文本，包括标点符号和空格，都是单个原子。这种原子被称作串(String)(代表字符串之意)，并且他是一种事物的分类，
以便让计算机能够打印出来，可供阅读的信息。字符串是不同于数字和符号的一种原子，，在使用上也是不同的。
*** 列表中的空格
列表中空格的数量无关紧要。从Lisp语言的角度来说，
#+begin_src lisp
  '(this list
         looks like this)
#+end_src
与下面的列表完全等价
#+begin_src
'(this list looks like this)
#+end_src
上面两个例子对Lisp而言是同一个列表。这个列表由标点符号：this list look like this 按照上面这种顺序组成。

多余的空格和换行符只不过是为了使人们便于阅读而设计的。当Lisp读取表达式时，它剔除了所有多余的空格（但是原子间至少需要一个空格以使原子分隔开来）。

这看起来很奇怪，我们已经看到的例子涵盖了Lisp列表的几乎所有的情况。其它任何一个Lisp列表看起来都或多或少的与上面的例子相似，只是列表可能更长，更复杂。
简要的说，列表放在括号之间，串放在引号之间，符号看起来像一个单词，而数字看起来就像一般的数字一样。

当然对于特定的情况，方括号，大括号，句点和一些特殊的字符都是可以使用的，然而我们暂时先不去理会他们。
*** GNU Emacs帮助你输入列表
如果你在GNU Emacs中使用Lisp交互模式或是Emacs Lisp模式来输入一个Lisp表达式，那么你将可以使用多种命令来使Lisp表达式排成易于阅读的格式。例如，按TAB键会使
光标所在的行自动缩排到适当的位置。用于在一个区域内正常缩排的常用命令是 M-C-\。设计缩排，是为了让读者看清列表的那些元素，是属于哪个列表的，缩排时子列表的
元素要比外围列表的元素更缩进一些。

另外，当输入一个右括号时，Emacs立即使光标跳到与之配对的左括号处，因此就可以看清它到底是哪个列表。这个功能非常有用，因为Lisp中输入的每一个列表必须有一对匹配的
左括号和右括号。
** 运行一个程序
Lisp中的一个列表------任何列表-----都是一个准备运行的程序。如果你运行它，计算机将完成三件事情：只返回列表本身，告诉你一个出错消息；或者将列表中的第一个符号
当作一个命令，然后执行这个命令。

单引号 ' ,也就是在前一节例子中的列表前面的引号，被称作一个引用(quote),当单引号位于一个列表之前时，他告诉Lisp不要对这个列表做任何操作，而仅仅是按其原样。但是
如果一个列表前面没有引号，这个列表中的第一个符号就很特别了：他是一条计算机要执行的命令(在Lisp中这些命令被称作函数)。上面说的列表(+ 2 2)就没有引号在前面，因此
Lis将 + 号理解为一条指令，用来对这个列表的其余部分进行操作；在这种你情况下，就是将其后续的数字相加。

如果在GNU Emacs的Info中阅读到这个列表，可以这样对他求值：将光标挪到下面列表的右括号之后，然后按 C-x C-e;
#+begin_src lisp
(+ 2 2)
#+end_src
你将在回显区看到数字4。用术语来说，刚才做的就叫做：对一个列表求值，回显区是屏幕底部的那一行，它显示或者回显文本。

现在，对下面带单引号的列表进行操作，将光标置于下面列表之后，然后按 C-x C-e:
#+begin_src lisp
'(this is a quoted list)
#+end_src
此时，将会看到 *(this is a quoted list)* 显示在回显区。

在这两种情况下，你所做的是给GNU Emacs内一个叫做Lisp解释器的程序一个命令，即给解释器一个命令，使之求值。Lisp解释器的名字来自于由一个人来完成某项任务这个词，这个
人给出了表达式的值，即他解释了它。

同样可以对一个不是列表的一部分的原子（即不被括号括起来的原子）求值。同样，Lisp解释器将人能理解的表达式翻译成计算机的语言。但是在讨论这个问题之前，我们先讨论出错
时Lisp解释器会做些什么。
** 产生错误信息
如果不小心出了错，也不要担心，我们将给Lisp解释器一个命令，使之产生一个错误消息。这是一个无害的动作，确实我们时常会有意识地产生错误消息。一旦理解了这种术语，错误消息是能提供
有用信息的。与其说是错误消息，不如说是有助的消息。他们就像是一个给在异国他乡的游客的路标，破译他们可能很艰难，但是一旦理解了，他们就成了指路明灯。

我们将要做的就是对一个没有引号并且其第一个元素不是一个有意义的命令的列表求值。
下面是一个与我们用到过的列表，几乎完全相同的列表，但是他前面没有单引号。将光标移动到它后面并输入 C-x C-e:
#+begin_src lisp
(this is an unquoted list)
#+end_src
这一次，将会看到下面的内容显示在回显区：
#+begin_src lisp
Symbol's function definition is void: this
#+end_src
另外，终端可能对你发出鸣叫声，有些终端这样做，有些终端不这样，有些则闪烁，这仅仅是一个示警装置，只要键入任何键，消息都将迅速消失，哪怕是仅仅移动了光标。

根据已有的知识，我们几乎可以读懂这条错误信息。我们知道 Symbol 一词的意义，在这种情况下，它指列表中的第一个原子，就是 this 这个词。上述错误消息中的 function一词在前面
已经出现过一次。他是非常重要的一个词，对我们的目的而言，可以将他定义为一个函数，就是一组告诉计算机做什么的计算机指令。

现在我们可以理解这条错误消息了：Symbol's function definition is void: this。其中 Symbol 是指 this 。这个错误消息是指没有为 this 定义让计算机执行的
任何指令。

这条错误消息中稍显奇怪的用词 function definition is void 是Emas Lisp实体方式的体现：即当一个符号没有一个对应的函数定义时，那个应当包含指令的位置就是空的 void

另一方面，因为可以成功的通过对表单时 (+ 2 2) 求值来执行2加2计算，那就是说 + 号一定有一组计算机执行的指令，这些指令就是将 + 后面的数字加起来。

** 符号名和函数的定义
在Lisp中一组指令可以连到几个名字，例如，计算机的加法指令可以连接到符号 Plus ,也可以连接到符号 + 。在人类社会中，我们可以叫做 Robert ,也可以叫做 Bob,或者其他的什么词。

另一方面，一个符号一次只能有一个函数定义与其连接，否则，计算机就会疑惑到底使用哪个函数。如果在人群中出现这种情况，那么只有一个人可以叫做 Bob,然而，一个名字指向的函数定义
是容易改变的。

因为 Emacs Lisp 很大,它常以一定的方式将符号命名，这个命名方法可以确定函数属于Emacs的哪个部分。因而，处理TextInfo的所有函数的名字都以 textinfo- 开头，所有用于阅读电子
邮件的函数的名字都以 rmail- 开头。

** Lisp解释器
Lisp解释器对一个列表求值时做了什么呢？

首先，它查看一下在列前面是否有单引号。如果有解释器就为我们给出这个列表。如果没有引号解释器就查看列表的第一个元素，并判断它是否是一个函数定义。如果他确实是一个函数，则解释器
执行函数定义中的指令。否则解释器打印一个错误消息。

这就是Lisp的工作方式，简单极了，后面我们会介绍更复杂的一些内容，但是这些是基本的。当然为了编写Lisp程序，需要知道如何书写函数定义，并将他们连向函数名，以及如何使得这样做不
使自己和计算机都搞混。

现在我们介绍第一种复杂的情况。除了列表之外，Lisp解释器可以对一个符号求值，只要这个符号前面没有 引号 也没有括号包围他，在这种情况下，Lisp解释器将试图像变量一样来确定符号的值。


出现第二种复杂的情况是因为一些函数异常并且以异常的方式运行，那些异常的函数被称作特殊表(special form)。他们用于特殊的工作，例如
定义一个函数。但是这些特殊表并不多。在下面几章将会接触到几个更加重要的特殊表。

第三种情况也是也是最后一种复杂的情况：如果Lisp解释器正在寻找的函数不是一个特殊表，而是一个列表的一部分，则Lisp解释器首先查看这个
列表中是否有另外一个列表，如果有一个内部列表，Lisp解释器首先解释将如何处理那个内部列表，然后再处理外层这个列表。如果还有一个列表
嵌入再内层列表中，则解释器将首先解释那个列表，然后逐一往外解释。它总是首先处理最内层的列表。解释器首先处理最内层的列表是为了找到它的
结果，这个结果可以由包含它的表达式使用。

否则，解释器从左到右工作，一个表达式接着一个表达式地进行解释。

*字节编译*

解释的另外一个方面是：Lisp解释器可以解释两种类型的输入数据：人可以读懂的代码（我们将着重关注这类代码）和经过特殊处理的、被称作字节编译的代码，字节编译的代码是人无法读懂的。字节
编译代码比人能读懂的代码运行的更快。

可以通过运行一个编译命令（如 byte-compile-file ）将人们读懂的代码，转换成字节编译代码。字节编译代码通常存储在一个文件之中，这个文件以 .elc 作为扩展名，而不是以 .el 作为扩展名。
可以在 emacs/lisp 目录中看到这种文件。可以阅读的文件是扩展名为 .el 的文件

实际上，用户可能做的绝大多数事情是定制或者扩展Emacs，对于这些事情无需进行字节编译。

** 求值
当Lisp解释器处理一个表达式时，这个动作被称作 求值 。我们称，解释器计算表达式的值。

完成表达式求值后，Lisp解释器几乎总是要返回一个值，这个值是计算机执行它在函数定义中找到的指令的结果，或者他将放弃那个函数并产生一个错误消息。
通常解释器会返回一个值。

在解释器返回一个值的同时，它也可以做些其它什么事情， 例如移动光标或者拷贝一个文件，这种动作被称为附带效果，我们认为的重要的事情，如打印一个文件，对Lisp解释器而言常常是一个附带效果。
这个行话显得有些独特，但是它表明学习使用附带效果是非常容易的。

总之对一个符号表达式求值几乎总是使Lisp解释器返回一个值，同时可能产生一个附带效果，不然就产生一个错误消息。

*对一个内部列表求值*

如果是对一个嵌套在另一个列表中的列表求值，对外部列表求值时可以使用首先对内部列表求值所得的结果。这解释了为什么内层列表总是首先被求值的：因为他们的返回值被用于外部表达式。

通过对下面这个例子的求值，可以深入理解这个过程。将光标置于下面的表达式的末尾，并键入 C-x C-e :
#+begin_src elisp
(+ 2 (+ 3 3))
#+end_src
如果将光标置于表达式下面一个空白行的开头，并键入： C-x C-e ,数字8仍将显示在回显区。现在将光标移动到表达式内部。如果将光标移动到倒数第二个括号之后，即光标覆盖在最后一个括号上，
执行求值命令，将看到数字6显示在回显区。因为求值命令是对表达式 (+ 3 3)进行求值的。

现在将光标立即置于一个数字之后。键入 C-x C-e,将得到这个数字本身。在Lisp中，如果对一个数字求值，将得到这个数字本身--------这就是数字区别于符号的地方。如果对一个以 + 号开头的列表
求值，将得到计算机执行这个符号名所附带的函数定义中的一组指令的结果。如果一个符号本身被求值，那么将会发生一些不同的事情。
** 变量
在Lisp中，可以将一个值赋给一个符号，就像将一个函数定义赋给一个符号那样。这两者的含义是不同的。函数定义是一组指令，这组指令是由计算机执行的。另一方面，一个值，比如一个数字或者
一个名字，是可以变化的（这就是为什么称其为变量的原因）。一个符号的值可以是Lisp中的任意表达式，如 一个符号， 一个数字， 一个列表 或者 一个字符串。有值的一个符号，通常被称作
一个变量(variable)。

一个符号可以同时具有一个函数定义和一个值。这两者是各自独立的。这有点像 Cambridge 一词，既可以指那个在麻省的Camridge市，也可以指其它赋予这个名字的信息，比如伟大的编程中心。

对于这个问题的另外一种思考是：将符号设置为一个有许多抽屉的柜子。函数定义放在一个抽屉中，值放在另外的抽屉中，等等。放在抽屉中的值可以在不影响其它抽屉中存放的函数定义的情况下被改变，
反过来也一样。

变量 fill-column展示了一个具有值的符号，在每一个GNU Emacs缓冲区中，这个符号被赋予一些值，通常是70或者72，但有时被赋予别的一些值。为了从这个符号中找到其中的值，对他本身求值
即可。如果在GNU Emacs的Info中阅读这份文档，可以将光标移动到这个符号的后面，并键入 C-x C-e;

任何值都可以赋给一个符号，用术语来说，就是将变量与一个值绑定（bind）起来，绑定到一个数字，如70；绑定到一个字符串，如 "such as this"绑定到一个列表，如(spruce pine oak)。
甚至可以将一个变量绑定到一个函数定义上。

一个符号可以有几种方法与一个值绑定。

注意，在我们对 fill-column 变量进行求值时，这个单词的两边没有括号。这是因为我们并不希望将他当作一个函数名使用，如果fill-column是一个列表仅有的一个原子或者第一个原子，Lisp解释器
将试图寻找与之相联系的函数定义。但是 fill-column 没有函数定义，试一试对下面的表达式求值:
#+begin_src lisp
(fill-column)
#+end_src
将得到这样一个错误消息：
#+begin_src text
Symbol's function definition is void: fill-column
#+end_src
*符号无值时的错误消息*

如果试图对一个没有赋值的符号求值，将收到一个错误消息。可以试试 2+2 的加法。在下面的表达式中，将光标紧紧挨在 + 后面，并在第一个2前面，键入 C-x C-e:
#+begin_src lisp
  (+ 2 2)
#+end_src
将得到这样一个错误消息：
#+begin_src text
Symbol's value as variable is void: +
#+end_src
这个错误消息与我们看到过的错误消息 Symbol's function definition is void: this 不同。在这个例子中没有被赋值的符号被当作一个变量。在前面那个情况下，符号 this 没有函数定义。
** 参量
为了理解信息是如何传送给函数的，让我们再看看上面多次提到的那个函数：2+2的和。在Lisp中，这写成：
#+begin_src elisp
(+ 2 2)
#+end_src
如果对这个表达式求值，数字4将出现在回显区中。Lisp解释器所做的就是将加号后面的数字加起来。

由 + 号相加的数字被称为 +函数 的参量，这些数字就是给予或者传递给函数的信息。

参量（argument）一词来自于他在数学中的应用，而不是指两个人之间的争论，相反，它指传递给函数的信息，在这个例子中就是传递给 +函数 。在Lisp中，一个函数的
参量是函数后面的原子或者列表。通过对传递给函数的原子或者列表求值，得到返回值，不同的函数需要不同数目的参量；有些函数根本就不需要参量。

*** 参量的数据类型
应当传递给函数的数据类型依赖于它使用什么信息。像 +函数 这样一个函数，其参量必须有数字类型的值，因为 + 意味着要将数字加起来。其它函数使用不同类型的数据
作为他们的参量。

例如，concat 函数将两个或者更多的字符串串联起来，产生一个新的字符串。这时参量的类型是字符串，将两个字符串 abc 和 def 连接起来就生成一个新的字符串 abcdef.
这可以通过对下面的表达式求值得到：
#+begin_src elisp
(concat "abc" "def" "ghijk")
#+end_src
求值得到的这个表达式的值为 "abcdefghijk".

一个函数（如： substring），即使用字符串也是用数字作为参量。这个函数返回字符串的一部分，即参数第一个参量的一个子字符串。这个函数需要三个参量，第一个参量
是一个字符串，第二个参量和第三个参量是指明子字符串开始和结束位置的数字。数字是指从字符串的首字符位置开始计数的（包含 空格和标点符号）；
#+begin_src elisp
(substring "The quick brown fox jumped" 16 19)
#+end_src
将在回显区中看到 "fox"

注意，传递给substring函数的字符串是一个单原子，虽然它由几个被空格分开的单词组成。Lisp将引号中的所有内容作为串的一部分（包括空格和标点符号）进行计数。可以将substring函数
当作一种”原子分裂器“，因为它接收其它不可分的原子，抽取其中的一部分。然而，substring函数仅能从一个字符串参量中抽取子字符串，而不是从其它类型的原子中抽取，如从一个数字或者一个符号
抽取。
*** 作为变量和列表的值的参量
参量可以是一个符号，对这个符号求值将返回一个值。例如，当符号fill-column被求值时，他返回一个数字。这个数字能给用于加法之中。将光标置于下面的表达式之后，并键入：C-x C-e:
#+begin_src elisp
(+ 2 fill-column)
#+end_src
其返回值是一个数，它比你单独求fill-column的值大2.

就像刚才看到的，参量可以是一个符号，当求值时这个符号返回一个值。另外，参量也可以是一个列表，当求值时这个列表返回一个值。例如，下面的表达式里，函数concat的参量是一个字符串
"The" "red foxed" 和列表 (+ 2 fill-column)。
#+begin_src elisp
(concat "The " (+ 2 fill-column) " red foxes.")
#+end_src
*** 数目可变的参量
有些函数如 concat + * 可以有任意多个参量。用通常的方法对下面的表达式求值就可以看到这一点。
1. 函数没有参量
   + (+)----------> 0
   + (*)----------> 1
2. 每个函数有一个参量
   + (+ 3) --------> 3
   + (* 3) --------> 3
3. 每个函数有三个参量
   + (+ 3 4 5) --------> 12
   + (* 3 4 5) --------> 60
*** 用一个错误类型的数据对象作为参量
当函数的一个参量被传送一个错误类型的数据时，Lisp解释器产生一个错误消息。例如 + 函数要求其参量都是数。作为一个实验，可以传送一个带引号的符号hello而不是
一个数给他。将光标置于下面的表达式之后，并键入 C-x C-e
#+begin_src lisp
(+ 2 'hello)
#+end_src
当这样做，就会产生一个错误消息。这里所发生的是： +函数试图将数字2和hello的返回值相加。但是 'hello 的返回值是符号，hello不是一个数。只有数字才能相加。
因此 + 函数不能执行他的加法。

一般的说，在学习了如何阅读错误信息之后，错误消息将是有帮助的，具有提示作用。上例的错误消息是：

Wrong type argument: integer-or-marker-p, hello

这个错误消息的前面部分是很直截了当的。他就是说 Wrong type a argument(参数类型错误)。后续部分来自神秘的术语"integer-or-marker-p".这是试图告诉你
+函数期望得到什么类型的参量。

符号integer-or-marker-p的意思是说，Lisp解释器试图确定提交给它（也就是参量的值）的信息是一个整数（也就是整个数）或者是一个标记（表示一个缓冲区位置的一个
特殊对象）。解释器所做的就是测试是否对传递给 +函数 的这个数进行加法运算。它同时也测试这儿参量是否是某些叫做标记的东西，这是Emacs Lisp的一个特殊的特性。（在
Emacs中，缓冲区中的位置是以标记来记录的。当执行 C-@ 或者 C-SPC 命令设置标记时，这个位置就被记录为一个标记。这个标记可以被当作一个数，就是从缓冲区开始到
这个位置为止的所有字符数）在Emacs Lisp中， +函数 可以将标记位置的值拿来当作一个数进行相加。

iterger-or-marker-p 中的 p 是早期Lisp研究人员编程实践的体现，这个 p 字符代表 predicate(即谓词)。在早期的Lisp研究人员使用的术语中，一个谓词是指一个决定
某些属性是否为真的函数。因此， p 告诉我们 integer-or-marker-p 是一个函数名，这个函数决定当提供的参量是一个整数或者一个标记时是否为真。其它以 p 结尾的Lisp
符号，包含zerop（这个函数测试参量值是否为零）和listp(这个函数测量是否是一个列表)。

最后，错误消息的最后部分是符号 hello 。这就是传送给 +函数 的参量的值。如果为这个 +函数 传递了正确类型的对象，这个值应当是一个数，如19，而不是一个像hello 这个的符号。
但是如果那样的话，你就不会得到一个错误消息了。

*** message函数
像 +函数 一样，message函数的参量数目是可变的。它被用于给用户发送消息。

消息是打印在回显区中的。例如，通过对下面的列表求值，就能够在回显区中打印一条消息：

(message "This message appears in echo area!")

双引号中的整个字符串是一个参量，他被打印出来.(在这个例子中应注意：引号中的消息本身将显示在回显区中，这是因为你看到的是message函数的返回值。在使用message函数的绝大多数
情况下，在回显区打印消息只是一个附带作用，而打印出来的消息则是没有引号的)

然而，如果在带引号的字符串中加有 %s ,message函数将不打印 %s ，而是去找紧跟在这个字符串后面的参量。它先对第二个参量求值，并将这个值打印到字符串中 %s 出现的位置。

将光标置于下面的表达式后并键入 C-x C-e,就可以看到上面说的这种情况。

(message "The name of this buffer is: %s" (buffer-name))

在Info中，"The name of this buffer is:*scratch*" 将出现在回显区。函数buffer-name以一个字符串的方式返回缓冲区的名字，message 函数将这个字符串插入以取代 %s.

为了输出一个十进制数，可以用类似于 %s 的方式，但使用 %s 来实现。例如，为了在回显区中打印一条告知fill-column值的消息，对下面的表达式求值即可：

(message "The value of fill-column is %s" fill-column)


在我的系统中，当对这个列表求值时，"The value of fill-column is 70"出现在我的回显区中。

如果在带引号的字符串中有多于一个的 %s ，字符串后面的第一个参量的值输出到第一个 %s 的位置，字符串后的第二个参量额值输出到第二个 %s 的位置，以此类推。例如，如果对下面的
列表求值：

#+begin_src lisp
  (message "There are %d %s in the office!"
           (- fill-column 14) "pink elephants")
#+end_src
一个相当古怪的消息将显示在回显区中。在我的系统上，他是 There are 58 pink elephants in the office!

表达式(- column 14) 被求值，其结果在同样的位置替换 %d ,双引号中的字符串 pink elephants 被当作一个参量并替换 %s 。这就是说，双引号中的串求值后就是它本身，就像一个数一样。

最后，这里有一个稍微复杂一点的例子。它不仅展示一个数的计算，同时也展示如何能够在一个表达式内部使用另外一个表达式来产生用于替换 %s 的文本：
#+begin_src lisp
          (message "He saw %d %s"
                   (- fill-column 34)
                   (concat "red"
                           (substring
                            "This qucik brown foxes jumped." 16 21)
                           "leaping"))
#+end_src
回显为：He saw 38 red foxes leaping

** 给一个变量赋值
有几种方法给一个变量赋值。其中一种方法是使用 set函数 或者使用 setq函数 。另外一种方法是使用 let函数。（这个过程用术语来说，就是将一个变量绑定到一个值上）。
*** 使用set函数
为了将符号flowers的值设置为列表 '(rose violet daisy buttercup),将光标置于下面的表达式后并键入C-x C-e来对表达式求值:
#+begin_src lisp
  (set 'flowers '(rose violet daisy buttercup))
#+end_src
列表(rose violet daisy buttercup) 将出现在回显区中。这是set函数返回的值。作为一个附带效果，符号flowers被绑定到一个列表上，也就是列表作为值被赋给可以被
当作变量的符号flowers。顺便说一下，这个过程，展示了Lisp解释器的附带效果（赋值）如何能成为我们感兴趣的主要作用。这是因为每个Lisp函数如果不产生一个错误消息的话，
他就必须要返回一个值，但是如果为函数设计一个附带效果的话，它将只有一个附带效果。

对set表达式求值之后（即赋值之后），能对符号flower求值，他将返回你刚设置的值。

下面就是这个符号。将光标置于它后面并键入 C-x C-e;

flower

当对flower求值时，列表(rose violet daisy buttercup)显示在回显区中。

附带提一下，如果对带单引号的变量求值，在回显区看到的将是这个符号flower本身。下面是带引号的符号

'flowers

同样要注意，当使用set函数时，需要将set函数的两个参量都用引号限定起来，除非你希望他们被求值。在这种情况下，我们不希望任何参量被求值，即不希望变量flowers被求值，
也不希望列表(rose violet daisy buttercup)被求值，因此他们都带引号。（在使用set函数时，如果没有将第一个参量用单引号标明，第一个参量将在所有其它操作执行之前被求值。
如果这样做了，而flowers又还没有值的话，将得到一个错误消息，即"Symbol's value as variable is void";另外一方面，如果flowers确实在求值后返回一个值，set函数将
试图设置这个返回的值。这确实是由函数完成的，但是很少这样做）。

*** 使用setq函数
实际上，人们总是将set函数的第一个参量用单引号标出。set函数和其第一个带引号的参量的组合是如此常用，以至于它有一个自己的名字：setq特殊函数。这个特殊表就像
set函数一样不同指出只在于其第一个参量自动带上单引号。因此，不必自己键入单引号了。同样，另外一个方便之处在于，setq函数允许在一个表达式中将几个不同的变量设置
成不同的值。

用setq函数将变量 carnivores 的值设置成列表 '(lion tiger leopard),可以使用西面的表达式完成：
#+begin_src lisp
(setq carnivores '(lion tiger leopard))
#+end_src

不同变量赋值不同用法：
#+begin_src lisp
  (setq trees '(pine fir oak maple)
        heriores '(gazelle antelop zebra))
#+end_src
这个表达式也可以写在一行上，但是这可能无法打印一张纸上，而且人们发现格式化的列表更易于阅读。

虽然我们已经使用 赋值 一词，但是还有另外一种方式来理解是 set 和 setq 函数。那就是，set 和 setq 函数将符号指向列表。后面这种思考的方式很常见，在后续几章
我们将至少在一个符号中用 指针 作为它名字的一部分。之所以选择这个术语，是因为符号有一个值，特别是一个列表赋给符号，或者用另一种方式说，就是符号 指向 这个列表。

*** 计数
这虽然有一个例子演示如何在计数器中使用setq函数。可以用这种方法对你的程序的某个部分重复多少次进行计数。首先，将一个变量赋值为0，然后每当程序自行重复一次就给这个变量加1.
为达到这一目的，你需要一个作为计数器的变量和两个表达式：第一个表达式是将变量赋值为0的初始化setq表达式，第二个表达式是每次求值时对计数器加1的setq表达式。

#+begin_src lisp
  (setq count 0)
  (setq count (+ count 1))
  count
#+end_src

* 第二章 求值实践
每当在Emacs Lisp中发出一个编辑命令时，比如一个移动光标或滚动屏幕的命令，就是在对一个表达式求值，这个表达式的第一个元素就是一个函数。这就是Emacs的工作方式。

当你击键时，你使Lisp解释器对一个表达式求值，于是你就得到了结果。即使是键入普通文本也是对Emacs Lisp的一个函数求值。在这种情况下，就是使用了 self-insert-command函数，或者是命令。
如何使一个函数编程交互函数将在如何编写函数定义中讲解。

除了键入键盘命令外，我们已经看到第二种对表达式求职的方法：将光标置于列表之后，并键入 C-c C-e。在这一章余下部分，我们将这样做。对表达式求值还有其它办法，这些方法将会在后续章节中描述。

除了用于求值实践之外，在下面几节中演示的函数本身都是很重要的。学习这些函数可帮助你弄清：缓冲区和文件的区别，如何切换至一个缓冲区以及如何确定在其中的位置。

** 缓冲区名
buffer-name 和 buffer-file-name 这两个函数显示文件和缓冲区之间的区别。当对表达式(buffer-name)求值时，缓冲区的名称将显示在回显区中出现。当对(buffer-file-name)表达式求值时，缓冲区所指的那个文件的名称将在回显区中出现。通常
情况下。由(buffer-name)返回的名称与(buffer-name)所指的文件名称相同，由(buffer-file-name)返回的名称是文件的完整的路径名。

文件和缓冲区时两个不同的实体。文件时永久记录在计算机中的信息（除非你删除了它）。而缓冲区时Emacs内部的信息，它在Emacs编辑会话结束时（或当取消缓冲区时）就消失了。通常情况下缓冲区包含了
从文件中拷贝过来的信息，我们称这个缓冲区正在 访问 那个文件。这份拷贝正式你加工或修改的对象，对这个缓冲区的改动不会该斌那个文件，除非你保存了这个缓冲区。当你保存这个缓冲区时，缓冲区中的内容被
拷贝到文件中去，因此被永久的保存下来。

如果在 GNU Emacs 的 Info 中阅读本教程，可以通过将光标置于下面的表达式后并键入 C-c C-e来对他们求值：
#+begin_src lisp
  (buffer-name)
  (buffer-file-name)
#+end_src
尽管缓冲区和文件由这些区别，但是你会经常发现人们在说一个缓冲区的时候是指文件，或者反过来。在实践中绝大多数人会说：我正在编辑一个文件， 而不是说： 我正在编辑很快就要存入文件的一个缓冲区。
从人们谈话的山下文中几乎总是可以知道人们真正所指的东西。然而，当处理计算机程序时，你在头脑中清楚的意识到这两者的区别时非常重要的，因为计算机可没有那么聪明。

缓冲区一词来自这个词可被用作 缓解碰撞力的软垫之意。在最早期的计算机里，缓冲区在文件和中央处理器之间的相互作用中起到缓和的作用。那是，磁鼓和磁带用于保存文件，他们和CPU是
彼此很不相同的设备，各自以其固有的速度高速运行。缓冲区是他们能够共同高效的工作。最终，缓冲区演变成为一个中间部件，一个临时存放区，计算机的工作就是在这里进行的。
这种变化就像一个小海港成长为一个大城市一样，原来它仅仅是尚未装上船的货物的临时仓库，后来以其自身条件发展成为一个商业和文化中心。

并不是所有的缓冲区斗鱼文件联系在一起。例如，当键入 emacs 命令启动一个Emacs会话时，没有给出任何文件，Emacs将在屏幕上启动一个 *scracth* 草稿缓冲区。这个缓冲区并没有任何访问文件。
类似的，一个 help 帮助缓冲区夜不语任何文件相关联。

如果切换到 scratch 缓冲区，键入 buffer-name 将光标置于列表之后，并键入 C-x C-e 对这个表达式求值，scratch 这个名字将显示在回显区中。 scratch 就是这个缓冲区的名字。
然而，如果输入 buffer-file-name 并求值，nil 将显示在回显区中。nil 意味着空，什么都没有。

C-u C-x C-e 这将使得返回值显示在表达式后面

** 获得缓冲区
buffer-name 函数返回缓冲区的名字。为了获得缓冲区本身，需要另外一个函数： current-buffer。如果在代码中使用这个函数，得到的将是这个缓冲区本身。

一个名字与名字所指向的对象或实体是互不相同的。你不是你的名字。你是一个用名字指向的人。如果你要求与George讲话，有人给你一张印有 G e o r g e这价格字母的名片。
你可能被搞糊涂，你不会满意的。你不是要对这个名字讲话，你是要对这个名字所指的那个人讲话。缓冲区就与此类此：草稿缓冲区的名字是 scratch ，但是这个名字本身不是缓冲区。
为了得到缓冲区本身，你需要使用一个函数： current-buffer

然而，这里带有一点复杂性：如果在缓冲区中的一个表达式内对current-buffer求值，就像我们将要做的那样，你所看到的是打印出来的这个缓冲区对应的名字，而没有缓冲区的内容。
Emacs这样做有两个理由：缓冲区可能有数千行长----显示起来太长了，不方便；而且另外一个缓冲区可能有同样的内容，只是名字不一样而已，将他们之间区分开来是很重要的。

下面是包含这个current-buffer函数的一个表达式：
#+begin_src lisp
  (current-buffer)
#+end_src
如果用常规的办法对这个表达式求值， #<buffer test.el> 将显示在回显区中这个特殊的格式表明这个缓冲区本身被返回了，而不仅仅是其名字。

顺便说一下，可以在一个程序中输入一个数字或者符合，但却不能用这种方法得到缓冲区的打印表示：得到缓冲区本身的唯一方法是用一个函数，如current-buffer函数。

一个相关的函数是 other-buffer 。这个函数返回最近使用过的缓冲区，而不是当前使用的那个缓冲区。如果最近经常对 *scratch*缓冲区不停的来回切换，那么 other-buffer函数将返回那个缓冲区。
** 切换缓冲区
当other-buffer函数被一个函数用作参量时，这个other-buffer函数实际上提供了一个缓冲区。通过使用othter-buffer函数和switch-to-buffer函数来切换到另外一个缓冲区，我们将看到这一点。

但是，先简单介绍一下switch-to-buffer函数。当在Info和草稿缓冲区 scratch之间来回切换来对 buffer-name 表达式求值时，很可能要键入键序列 C-x b,并当在小缓冲区中提示要求你输入
希望切换到的缓冲区名字时输入 scratch 。键序列C-x b,使Lisp解释器对交互性的Emacs Lisp 函数 switch-to-buffer 求值。正像我们前面讲的，这就是Emacs的工作方式：不同的键序列
调用和运行不同的函数。例如，C-f 调用forward-char函数，M-e调用forward-sentence函数，等等。

在一个表达式中写入 switch-to-buffer函数，并给他一个要切换到的缓冲区，就可以像C-x b那样切换缓冲区了。

以下就是完成这个任务的Lisp表达式：

#+begin_src lisp
(switch-to-buffer (other-buffer))
#+end_src
符号switch-to-buffer是这个列表的第一个元素，因此Lisp解释器将它视作成一个函数，并执行这个函数的指令。但在这样之前，解释器将注意到 other-buffer在一个括号内，
因此先处理这个列表。other-buffer 是这个列表的第一个元素（在这种情况下也是仅有的一个元素），因此Lisp解释器调用和运行这个函数。它返回另外一个缓冲区。下一步，解释器运行switch-to-buffer
函数，将另外这个缓冲区作为一个参量传送给他。这后面一个缓冲区就是Emacs要切换到的缓冲区。

在本教程的后续编程例子中，将更多的看到 set-buffer函数，而不是switch-to-buffer函数。这是因为人和计算机程序之间的一个差别：人有眼睛，并希望他们工作的计算机终端上看到缓冲区。
这是如此的直观，几乎不言自明。然而，计算机没有眼睛，当计算机程序工作在一个缓冲区时，缓冲区无序在屏幕上显示出来。

switch-to-buffer函数时人为设计的，它完成两件不同的事：一是切换到Emacs关注的缓冲区；一是从当前显示在窗口中的缓冲区切换到另一个新的缓冲区。另一方面，set-buffer函数 只做一件事；他将
计算机的注意力切换到另外一个不同的缓冲区。屏幕上现实的缓冲区并不改变（当然，知道命令运行完之前一般这不会发生任何事情）。

这里，我们已经接触到了另外一个术语：调用（call）。当对第一个元素是一个函数的列表求值时，就是在调用那个函数。这个词的使用来自这样的概念，函数作为一个实体，如果 呼叫 它，它可以为你做某些事情
就像水管工人在你呼叫他的时候能帮你补漏一样。

** 缓冲区大小和位点的定位
最后，来看看几个相当的函数： buffer-size,point,point-min,point-max。这些函数给出缓冲区大小以及其中的位点的位置等细腻。

buffer-szie 函数给出当前缓冲区的大小，也就是，这个函数返回关于这个缓冲区中字符数的计数： (buffer-size)

在Emacs中光标所在的当前位置被称为 位点 。表达式返回一个数字，这个数字给出光标所在的位置，即从这个缓冲区首字符开始到光标所在位置之间的字符数。

用通常的办法对下面的表达式求值，你可以看看光标在这个缓冲区中当前位点的字符计数： (point)

point-min函数 和 point函数 有点类似，但是它返回在当前缓冲区中位点的最小可能值。除非设置了变窄(narrowing),这个值一般就是1.变窄是一种自我限制的机制，限制用户
或者一个程序只能对缓冲区的一部分进行操作，与此类似，函数 point-max 返回在当前缓冲区中位点的最大可能值。

* 第三章 如何编写函数定义
当Lisp解释器对一个列表求值时，它查看列表中的第一个符号是否有一个与之联系在一起的函数定义，或者用另外一种说法，就是第一个符号是否指向一个函数定义。如果他确实有一个函数定义，
计算机执行函数定义中的指令。有函数定义的符号被简单的称作一个函数（虽然正确的说法时这个函数的定义，函数符号指向这个定义）。

除了一些基本函数用C语言编写的之外，其它所有函数都是用别的函数来定义的。你将在Emacs Lisp中编写函数的定义，并用其它函数作为你的基本构件。你将要用到的一些函数本身就是用
Emacs Lisp编写的（可能就是你编写的），而另一些基本函数可能是用C语言编写的。这些基本函数的用法与Emacs Lisp编写的函数的用法完全一样，表现也很相似。由于他们是C语言编写的，因此
我们可以容易的在任何运算能力足够强，能运行C程序的计算机上运行GNU Emacs。

再次重申一次：当你在Emacs Lisp中编写代码时，你无法分清在C语言中编写的函数和在Emacs Lisp中编写的函数。他们之间的区别是不相关的。之所以提到他们的区别是因为知道这一点很有趣。
实际上，除非你深入研究，否则你将不知道已经编写好的函数使用Emacs Lisp编写的还是用C语言编写的。

** defun 特殊表
在Lisp中，一个类似于mark-whole-buffer 这样的符号已经有代码与之联系了，这告诉计算机当函数被调用时要做些什么。改代码被称作函数定义，他是通过对一个以符号 defun
开头的Lisp表达式求值而被建立的。因为defun不以通常的方式对他的参量求值，因此他被成为特殊表。

在后续的章节中，我们将从Emacs源代码（如 mark-whole-buffer）来看看函数定义的问题。在这一节中，我们将描述一个简单的函数定义，因此你可以看看他是什么样子。这个函数定义用到了算数，
因为他是一个非常简单的例子。

一个函数定义在defun一词之后最多有下列五个部分：
+ 符号名，这是函数定义将要依赖的符号。
+ 将要传送给函数的参量列表。如果没有任何参量传送给函数，那它就是一个空列表().
+ 描述这个函数的文档。（从技术上说，这部分是可选的，但是我强烈推荐使用）。
+ 一个使函数成为交互函数的表达式，这是可选的。因此，可以通过加入M-x和函数名来使用它，或者键入一个适当的键或者键序列来使用它。
+ 指导计算机如何运行的代码，这是函数定义的主题

将函数定义的五个部分有序的组织成一个模板是很有用的，每个部分都有其自己的位置：
#+begin_src lisp
      (defun function-name(arguments...)
        "optional-document...."
        (interactive argument-passing-info) ;optional
        body....)
#+end_src
作为一个例子，下面是一个函数的代码，这个函数将他的参量乘以7。非交互式例子
#+begin_src lisp
    (defun multiply-by-seven(number)
      "Multiply number by seven"
      (* 7 number))
#+end_src
这个定义以括号和符号defun开始，后接函数名。

函数名后接一个列表，这个列表包含将要传送给这个函数的参量。这个列表被称作参量列表，在目前情况下，这个参量列表仅有一个元素，即符号number。当这个函数被使用时，
这个符号将被绑定到一个值上，就像参量被绑定到函数上一样。

若不选择number这个词作为这个参量的名字，也可以用其他任何名字

参数列表之后跟随着描述函数的文档字符串。这就是当键入 C-h f并输入函数名时看到的内容。顺便说一下,当你编写类似这样一个文档字符串时，应当使其第一行是一个完整的句子，
因为有些命令（如apropos）仅仅打印多行文档字符串的第一行。同样他，如果有第二行，不要在第二行缩进文档字符串，因为当你使用C-h f (describ-function)时，看起来会很奇怪。
文档字符串是可选的，但是它很有用，几乎所有你编写的函数都应当包含他。
** 使函数成为交互函数
使一个函数成为交互函数可以这样实现：在函数文档后面增加一个以特殊表interactive开始的列表。用户键入 M-x 和函数名就可以激活一个交互函数，或者键入绑定的键序列也可以
激活他，例如键入 C-n 可以激活 next-line 函数； 键入 C-x可以激活mark-whole-buffer函数。

有趣的是，当用交互的方法调用一个交互函数时，函数的返回值不会自动显示在回显区中。这是因为你一般总是喜欢得到调用交互函数的附带效果。例如，向前移动一个字或者一行，而不在乎返回值。
如果每键入一个键，返回值都显示在回显区中，这很分散注意力。

使用特殊表interactive和在回显区中显示一个值这两种办法都能通过创建一个交互形式的multiply-by-seven函数面前得到验证。

代码如下：
#+begin_src lisp
      (defun multiply-by-seven(number)
        "multiply"
        (interactive "p")
        (message "The result is %d" (* 7 number)))
#+end_src
通过将光标置于上面的函数定义之后并键入 C-x C-e 对其进行求值，就可以将这个函数定义安装。p告诉Emacs要传送一个前缀参量给这个函数，并将它的值用于函数的参量

函数名将显示在回显区。然后，通过键入 C-u 和一个数字并键入 M-x multiply-by-seven 和按下回车键，就可以使用这个函数了。加上了结果的句子"The result is ...."将显示在回显区中。

更一般的说，可以用下列两种方法之意激活一个函数：
+ 键入一个包含了传送始函数的数字的前缀参量和M-x以及函数名。如下列所示：C-u 3 M-x forward-sentence;
+ 键入函数绑定键或者键序列，如下所示：C-u 3 M-e。

这两种方法结果都是一样的，都将位点向前移动了三个句子。（因为multiply-by-seven没有绑定键，它不能被用作键绑定的例子）

** interactive函数的不同选项
在上面的例子中，multiply-by-seven函数使用 p 作为交互命令interactive的参量。这个参量告诉Emacs将你正在键入的C-u加上一个数字或META加上一个数字解释为一个命令，
用来将这个数字作为参量传送给函数。Emacs有多余20个为interactive预先定义好的字符。在几乎每一种情况下，一个或者多个这种选项将是你能将正确的信息交互地选送给函数。

例如，字符 r 使Emacs将位点所在区域的开始值和结束值作为函数的两个参量。

在另一方面， B 告诉Emacs用缓冲区的名字作为函数的参量。在这种情况下，Emacs会在小缓冲区提示用户输入缓冲区的名字，并使用跟在 B 后面的字符串表示这种要求（如："BAppend to buffer:"）。Emacs不仅提示输入函数名，而且如果用户给出了足够的信息并
按下 TAB键，Emacs会自动补齐函数名。

对于有两个或者更多参量的函数，对其参量可以各有各的值，在interactive中相应地增加一些内容就行了。当你这样做时，这些信息以其在interactive中定义的顺序传送给在
"BAppend to buffer:"后面加上一个 \n 分隔开，这代表一个新的行。例如，你可以在"BAppend to buffer:"后面加上一个 \n 和一个 \r 。这将使Emacs将位点和标记的值
传送给函数并提示你输入缓冲区名字-----一共是三个参量。

在这个例子中，函数定义看起来就像下面的例子一样。其中buffer,start,end是interactive绑定的当前缓冲区以及当前区域的起始值和结束值的符号：
#+begin_src lisp
      (defun name-of-function(buffer start end)
        "document...."
        (interactive "BAppend to buffer:\nr")
        body-of-function....)
#+end_src

如果一个函数没有参量，interactive就不需要任何东西。这样的函数只有一个简单的表达式：(interactive)。mark-whole-buffer 函数就是这样的。

作为选择，如果这些特殊控制符都无法满足你的应用需要，你可以将自己的参量传送给interactive作为一个列表。

** 永久的安装代码

** let函数
let表达式是Lisp中的一个特殊表，用户在绝大多数函数定义中都需要它。因为let表达式是如此的通用，所以这一节将专门介绍他。

let 用于将一个符号附着到或者绑定到一个值上，对于这样绑定的变量，Lisp解释器就不会将其与函数之外的同名变量混淆了。理解为什么这是一个特殊是很必要的。考虑一下这种情况：
你拥有一个家，在句子中你一般将其成为房子，房子需要粉刷。如果你在拜访你的朋友时，他提到房子，它是指他的房子而不是你的房子，即一栋不同的房子。如果他指他的房子，而你认为他是在
指你的房子，你们可能就弄糊涂了。如果一个函数中的一个变量与另外一个函数中的某个变量同名，而且他们原来就不是指同一件事情，类似的混淆事情也可能发生在Emacs中。

let特殊表就避免了这种情况发生。let创建的局部变量屏蔽了任何在这个表达式之外的同名的变量。这就像每当你的朋友提到房子时就是指他的房子而不是你的房子一样

由let表达式创建的局部变量只是在let表达式中保留它们的值（当然也可以在let表达式调用的表达式中保留局部参量的值，）局部变量不会影响let表达式之外的东西。

let表达式一次可以创建多个变量。同时，let表达式给每个变量赋由你创建的一个初始值，或者赋由你给定的一个值，或者赋nil（用术语来说，这是将变量绑定到值上）。let表达式创建并
绑定变量之后它执行let表达式主体本身(即对let表达式求值)，并返回表达式主题中最后一个表达式的值，这作为整个let表达式的返回值。（执行 是一个术语，表示对一个列表求值；
他的词义来自于 给予实际的效果 。由于你对一个表达式求值是为了完成某个动作，因此 “执行”一词被演化成为 求值 一词）；

*** let表达式的各个部分
let表达式是一个具有三个部分的列表。let表达式的第一个部分是let符号。第二部分是一个列表，称为变量列表。这个列表的每一个元素是一个符号或者一个两元素的列表，而它的第一个元素一定是一个符号。
let表达式的第三个部分是let表达式主体，这个主题由一个或者多个列表组成。

let表达式的模板看起来如下所示：
(let varlist body....)

变量列表中的符号是由let特殊表赋初始值的变量。符号本身的初始值是nil。作为两元素列表的首元素的每一个符号将被绑定到的对第二个元素求值后的返回值。

因而，变量列表就是这个样子:(thread (needles 3))。在这个例子中，在一个let表达式中，Emacs将符号thread绑定到初始值nil，并将符号needles绑定到初始值3上。

当你编写一个let表达式时，你所要做的就是将适当的表达式添入let表达式模板的适当位置。

如果变量列表是由两元素列表组成的，就可以采用下面的let表达式模板：
#+begin_src lisp
  (let ((variable value)
        (variable value)
        .....)
    body....)
#+end_src

*** let表达式例子
下面的表达式创建两个变量zebra和tiger,并给他们赋初值。这个let表达式的主题是一个使用message函数的列表。
#+begin_src lisp
    (let ((zebra 'stripes)
          (tiger 'fierce))
      (message "One kind of animal has %s and another is %s" zebra tiger))
#+end_src
在这个例子中，变量列表是：((zebra 'stripes)(tiger 'fierce))。

例子中的两个变量是：zebra 和 tiger。每个变量都是各自所在的两元素列表的第一个元素，它们的值分别是两元素列表的第二个元素。在变量列表中，Emacs将变量zebra绑定到
值stripes,将tiger绑定到值fierce。在这个例子中，这两个值都是标引号的符号。当然，绑定到变量上的值也可以是其它列表或者字符串。let表达式的主体跟在变量列表之后。在这个例子中。
let表达式主体是一个列表，这个列表使用message函数往回显区中打印一个字符串。

可以使用通用的方法对上面的例子求值，将光标置于最后一个括号之后，键入C-x C-e。当键入这些命令时，下面的字符串将显示在回显区中：

One kind of animal has stripes and another is fierce.

就像我们前面看到的那样，message函数将它的第一个参量（不含 %s）打印到回显区中。在这个例子中，变量zebra的内容打印到第一个 %s 的位置上，而变量tiger的内容打印到第二个 %s 的位置。

*** let语句中的初始化变量
在let语句中，如果没有将变量绑定到用户指定的一个特定的初始值上，则他们将被自动的绑定到 nil 这个初始值上。
** if特殊表
除了defun和let特殊表之外，第三个特殊表就是if条件特殊表。

写法模板为：
#+begin_src lisp
  (if true-or-false-test
      action-to-carry-out-if-test-is-true)
#+end_src
真假测试是一个由Lisp解释器求值的表达式

这是一个可以用通常的办法求值的例子。这个例子是5是否大于4.因为5大于4，因此消息 5 is greater than 4 将被打印出来。
#+begin_src lisp
  (if (> 5 4)
      (message "5 is greater than 4")
#+end_src
*** if-then-else表达式
if表达式可以有第三个参量，成为else部。这是为真假测试返回 假 时使用的。当真值测试返回 假 时，if表达式的第二个参量(即then部)不被求值，但是其第三部分（即else部）被求职。
可以将这理解为 如果天气晴朗暖和，就去海滨吧，否则就读书 这种选择中作为多云天气的一种选择。

else 一词不被写在Lisp代码中，if表达式的else部紧接在 then 部的后面。在Lisp中，else 部经常在一个新行中书写，并且缩进的比then部少：
#+begin_src lisp
    (if true-or-false-test
        action-to-carry-out-if-the-test-returns-true
      action-to-carry-out-if-the-test-returns-false)
#+end_src
例如，如果用通常的办法求值，则下面的if表达式将消息 4 is not greater than 5 打印出来。
#+begin_src lisp
  (if (< 4 5>)
    (message "4 is not greater than 5")
  (message "4 is greater than 5"))
#+end_src
注意，不同的缩进尺度使then部分与else 部分别开来。
** Lisp中的真与假
nil为假，非nil为真。
** save-excursion函数
save-excursion函数是第四个特殊表。

在Emacs中，Lisp程序常用作编辑文档，save-excursion函数在这些程序中很常用。这个函数将当前的位点和标记保存起来，执行函数体，然后，如果位点和标记点发生改变
就将位点和标记点恢复成原来的值。这个特殊表的主要目的是使用户避免位点和标记的不必要移动。

位点我们已经知道就是光标位置。

标记（mark）是缓冲区中的另外一个位置，它的值可以用一个命令（如 C-SPC (set-mark-command)）来设置。如果设置了一个标记，可以用命令C-x C-x(exehange-point-and-mark)
使光标从位点跳到标记点，并将光标当初所处的位置设置成一个标记。另外，如果设置了另一个标记，原来标记的位置就将保存在标记环中，用这种方法可以保存许多标记位置。可以
一次或者多次键入 C-u C-SPC命令来使光标跳到被保存的标记处。

* 第四章 与缓冲区有关的函数
这一章，我们将详细学习几个GNU Emacs中使用的函数。我们称之为一次“浏览”。这些函数是作为Lisp代码的例子使用的，但是这些并不是很具有创造性的例子。除了其中
第一个简化了的函数定义之外，这些函数显示了在GNU Emacs中实际使用的代码。可以从这些函数定义中学到很多东西。

** 查找更多信息
+ C-h f 函数名 enter : 得到任何一个Emacs Lisp 函数的全部文档。
+ C-h v 变量名 enter : 得到任何变量的全部文档。

同样，如果在一个原始的源代码文件中查看一个函数定义，可以使用find-tage函数跳到响应的位置。键入 M-. 然后在提示符下输入要查看的源代码的函数名，
** 简化的beginning-of-buffer函数定义
beginning-of-buffer 命令是一个很好的开始。作为一个交互命令，beginning-of-buffer函数将光标移动到缓冲区开始位置，在原来的位置设置一个标记。这个函数
一般绑定到 M-< 。

简化的beginning-of-buffer 函数的完整代码
#+begin_src lisp
  (defun simplified-beginning-of-buffer()
    "Move point to the beginning of the buffer; leave mark at previous position."
    (interactive)
    (push-mark)
    (goto-char (point-min)))
#+end_src
就像所有的函数定义一样，这个定义在特殊表defun之后有五个部分
+ 函数名
+ 参数列表
+ 文档字符串
+ 交互表达式
+ 函数体
在这个函数定义中，参量列表是空的。这意味着这个函数无需任何参量。

交互表达式，告诉Emacs这个函数可以被交互的使用。在这个例子中，interactive没有参量，因为函数定义中不需要要参量

函数体由两行组成
#+begin_src lisp
  (push-mark)
  (goto-char (point-main))
#+end_src
上述两行中第一行是一个表达式(push-mark)。当Lisp解释器对这个表达式求值时，它在光标的当前位置（无论是哪个位置）设置一个标记。这个标记的位置被保存到标记环中。

第二行是表达式(goto-char (point-min))。这个表达式将光标跳到本缓冲区的最小可能位点处，也就是缓冲区的开始处（如果变窄开启，就是这个缓冲区中可访问部分的开始处）。
** mark-whole-buffer函数定义
mark-whole-buffer函数并不比simplified-beginning-of-buffer 函数更难理解。然而，在这个例子中，将讨论这个函数的完整的代码而不是一个简化的版本。

它将整个缓冲区作为一个域来标记，方法是将位点置于缓冲区开始的位置，在缓冲区的末尾位置放一个标记。这个命令一般绑定到 C-x h。

函数完整示例代码：
#+begin_src lisp
      (defun mark-whole-buffer()
        "put point at beginning and mark at end of buffer"
        (interactive)
        (push-mark (point))
        (push-mark (point-max))
        (goto-char (point-min)))
#+end_src
** append-to-buffer函数定义
append-to-buffer 命令几乎像mark-whole-buffer命令一样简单。这个命令的功能就是从当前缓冲区中拷贝一个域。它从一个缓冲区提取一部分作为一个字符串。并将这个字符串
插入到另一个缓冲区中。append-to-buffer函数的绝大部分工作就是为了insert-buffer-substring函数创建适当的条件：即把他的代码必须指定字符串的来源缓冲区和目的缓冲区。
下面就是这个函数定义的全部内容：
#+begin_src lisp
            (defun append-to-buffer(buffer start end)
              "Append to specified buffer the text of the region.It is inserted into that buffer before ites point.when calling form a program,give three
          arguments: a buffer or the name of one, and two character numbers specifying the portion of the current buffer to be copied."
              (interactive "Bappend to buffer: \nr")
              (let ((oldbuf (current-buffer)))
                (save-excursion
                  (set-buffer (get-buffer-create buffer))
                  (insert-buffer-substring oldbuf start end))))
#+end_src
*** append-to-buffer函数的交互表达式
*** append-to-buffer 函数体
* 第五章 更复杂的函数
** copy-to-buffer 函数的定义

* 配置.emacs文件
** 全站点的初始化文件
除了你个人的初始化文件之外，如果存在全站点初始化文件，Emacs将自动加载各种不同的全站点初始化文件。这些文件的格式与你个人的初始化文件的格式是一样的。但是这些文件供所有人加载。

最常见的情况是， site-load.el   site-init.el

其它三个全站点初始化文件在你每一次使用Emacs时就会被自动地加载（如果着三个文件存在的话）。这些文件中 site-start.el 文件在用户个人的初始化文件 .emacs加载之前被加载，
default.el以及终端类型文件都是在用户个人的初始化文件 .emacs 加载之后被加载
